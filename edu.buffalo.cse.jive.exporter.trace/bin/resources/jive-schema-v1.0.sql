/** 
 * ************************************************************
 *           NON-TEMPORAL SECTION OF THE JIVE SCHEMA          
 * ************************************************************
 */

/** 
 * ************************************************************
 *                       CONSTANT TABLES 
 * ************************************************************
 */
 
CREATE TABLE value_kind AS (
  SELECT id, name FROM 
  (VALUES
    ( 1,'IM_CONTOUR_REFERENCE'),
    ( 2,'IM_METHOD_CONTOUR_REFERENCE'),
    ( 3,'IM_PRIMITIVE'),
    ( 4,'NULL'),
    ( 5,'OM_METHOD_KEY_REFERENCE'),
    ( 6,'OM_METHOD_REFERENCE'),
    ( 7,'OM_RESOLVED'),
    ( 8,'OUT_OF_MODEL'),
    ( 9,'SYSTEM_CALLER'),
    (10,'UNINITIALIZED')) AS R(id, name)
);
COMMENT ON TABLE value_kind IS 'Kinds associated with values in the model. Each kind has a different representation and/or interpretation.';

CREATE TABLE node_kind AS (
  SELECT id, name FROM 
  (VALUES
    ( 1,'NK_ARRAY'),
    ( 2,'NK_CLASS'),
    ( 3,'NK_ENUM'),
    ( 4,'NK_FIELD'),
    ( 5,'NK_FILE'),
    ( 6,'NK_INTERFACE'),
    ( 7,'NK_METHOD'),
    ( 8,'NK_PRIMITIVE'),
    ( 9,'NK_ROOT'),
    (10,'NK_VARIABLE')) AS R(id, name)
);
COMMENT ON TABLE node_kind IS 'Kinds of static nodes created by Jive at run-time.';

CREATE TABLE node_modifier AS (
  SELECT id, name FROM 
  (VALUES
    -- classes, methods
   ( 1,'NM_ABSTRACT'),
    -- classes
   ( 2,'NM_ANONYMOUS'),
    -- variables
   ( 3,'NM_ARGUMENT'),
    -- methods
   ( 4,'NM_BRIDGE'),
    -- variables
   ( 5,'NM_CATCH_VARIABLE'),
    -- fields
   ( 6,'NM_COMPILE_TIME_FINAL'),
    -- methods
   ( 7,'NM_CONSTRUCTOR'),
    -- fields
   ( 8,'NM_ENUM_CONSTANT'),
    -- methods
   ( 9,'NM_FIELD_INITIALIZER'),
    -- classes, methods, fields, variables
   (10,'NM_FINAL'),
    -- classes
   (11,'NM_LOCAL'),
    -- methods
   (12,'NM_NATIVE'),
    -- JIVE variable
   (13,'NM_RESULT'),
    -- JIVE variable
   (14,'NM_RPDL'),
    -- classes, methods, fields
   (15,'NM_STATIC'),
    -- methods, blocks
   (16,'NM_SYNCHRONIZED'),
    -- methods, fields
   (17,'NM_SYNTHETIC'),
    -- fields
   (18,'NM_TRANSIENT'),
    -- methods
   (19,'NM_TYPE_INITIALIZER'),
    -- fields
   (20,'NM_VOLATILE')) AS R(id, name)
);
COMMENT ON TABLE node_modifier IS 'Modifiers of the nodes created by Jive at run-time. Modifiers are used in the dynamic analysis and also for UI rendering.';

CREATE TABLE node_origin AS (
  SELECT id, name FROM 
  (VALUES
    -- obtained from AST
    (1,'NO_AST'),
    -- obtained from JDI
    (2,'NO_JDI'),
    -- generated by Jive
    (3,'NO_JIVE')) AS R(id, name)
);
COMMENT ON TABLE node_origin IS 'Origin of the nodes created by Jive at run-time.';

CREATE TABLE node_visibility AS (
  SELECT id, name FROM 
  (VALUES
    (1,'NV_LOCAL'),
    (2,'NV_PACKAGE'),
    (3,'NV_PRIVATE'),
    (4,'NV_PROTECTED'),
    (5,'NV_PUBLIC')) AS R(id, name)
);
COMMENT ON TABLE node_visibility IS 'Visibility scope associated with the nodes created by Jive at run-time.';

CREATE TABLE rline_kind AS (
  SELECT id, name FROM 
  (VALUES
    ( 1,'LK_ASSIGNMENT'),
    ( 2,'LK_ASSIGNMENT_ARRAY_CELL'),
    ( 3,'LK_BREAK'),
    ( 4,'LK_CATCH'),
    ( 5,'LK_CLASS_INSTANCE_CREATION'),
    ( 6,'LK_CONDITIONAL'),
    ( 7,'LK_CONSTRUCTOR_INVOCATION'),
    ( 8,'LK_CONTINUE'),
    ( 9,'LK_DO'),
    (10,'LK_DO_NOOP'),
    (11,'LK_ENHANCED_FOR'),
    (12,'LK_ENUM_CONSTANT_DECLARATION'),
    (13,'LK_FIELD_DECLARATION'),
    (14,'LK_FOR'),
    (15,'LK_IF_THEN'),
    (16,'LK_IF_THEN_ELSE'),
    (17,'LK_INITIALIZER'),
    (18,'LK_METHOD_CALL'),
    (19,'LK_METHOD_DECLARATION'),
    (20,'LK_POSTFIX'),
    (21,'LK_POSTFIX_ARRAY_CELL'),
    (22,'LK_PREFIX'),
    (23,'LK_PREFIX_ARRAY_CELL'),
    (24,'LK_RETURN'),
    (25,'LK_RETURN_IN_TRY'),
    (26,'LK_SUPER_CONSTRUCTOR'),
    (27,'LK_SUPER_METHOD_CALL'),
    (28,'LK_SWITCH'),
    (29,'LK_SWITCH_CASE'),
    (30,'LK_SYNCHRONIZED'),
    (31,'LK_THROW'),
    (32,'LK_VARIABLE_DECLARATION'),
    (33,'LK_WHILE')) AS R(id, name)
);
COMMENT ON TABLE rline_kind IS 'Kinds of line generated by Jive during the AST analysis.';

CREATE TABLE contour_kind AS (
  SELECT id, name FROM 
  (VALUES
    (1,'CK_INSTANCE'),
    (2,'CK_INSTANCE_VIRTUAL'),
    (3,'CK_METHOD'),
    (4,'CK_STATIC')) AS R(id, name)
);
COMMENT ON TABLE contour_kind IS 'Kinds of contours created by Jive at run-time.';

CREATE TABLE event_kind AS (
  SELECT id, name FROM 
  (VALUES
    ( 1,'EXCEPTION_CATCH'),
    ( 2,'EXCEPTION_THROW'),
    ( 3,'FIELD_READ'),
    ( 4,'FIELD_WRITE'),
    ( 5,'LINE_STEP'),
    ( 6,'THREAD_LOCK'),
    ( 7,'METHOD_CALL'),
    ( 8,'METHOD_ENTERED'),
    ( 9,'METHOD_EXIT'),
    (10,'METHOD_RETURNED'),
    (11,'MONITOR_LOCK_BEGIN'),      -- thread_state --> TS_BLOCKED
    (12,'MONITOR_LOCK_END'),        -- thread_state --> TS_RUNNING
    (13,'MONITOR_LOCK_FAST'),       -- thread_state --> TS_BLOCKED
    (14,'MONITOR_RELOCK'),          -- thread_state --> TS_BLOCKED
    (15,'MONITOR_UNLOCK_BEGIN'),    -- thread_state --> unchanged
    (16,'MONITOR_UNLOCK_COMPLETE'), -- thread_state --> TS_RUNNING
    (17,'MONITOR_UNLOCK_END'),      -- thread_state --> TS_RUNNING if lockCount = 0
    (18,'MONITOR_UNLOCK_FAST'),     -- thread_state --> TS_RUNNING if lockCount = 0
    (19,'NEW_OBJECT'),
    (20,'SYSTEM_END'),
    (21,'SYSTEM_START'),
    (22,'THREAD_CREATE'),           -- thread_state --> TS_CREATED
    (23,'THREAD_END'),              -- thread_state --> TS_TERMINATED
    (24,'THREAD_PRIORITY'),         -- thread_state --> unchanged
    (25,'THREAD_SLEEP'),            -- thread_state --> TS_WAITING
    (26,'THREAD_START'),            -- thread_state --> TS_RUNNING
    (27,'THREAD_WAKE'),             -- thread_state --> TS_RUNNING
    (28,'THREAD_YIELD'),            -- thread_state --> TS_WAITING
    (29,'TYPE_LOAD'),
    (30,'VAR_ASSIGN'),
    (31,'VAR_DELETE')) AS R(id, name)

);
COMMENT ON TABLE event_kind IS 'Trace events supported by Jive. Some are Jive generated at run-time, some are loaded from offline traces.';

/** 
 * ************************************************************
 *                     VALUE MODEL SECTION                    
 * ************************************************************
 */

CREATE UNLOGGED TABLE value (
  vid bigint,                 -- value identifier
  kind int,                   -- kind of this value
  value text                  -- textual representation of this value
);
COMMENT ON TABLE value IS 'Mapping from IValue. All values have a kind and a textual representation-- does not include contour references.';

CREATE INDEX ix_value_vid ON value(vid);

CREATE UNLOGGED TABLE value_cref (
  vid bigint,                 -- value identifier
  kind int,                   -- kind of this value
  contourId bigint            -- references contour_context.contourId
);
COMMENT ON TABLE value_cref IS 'Mapping from IContourReference and IMethodContourReference. All in-model contour references.';

CREATE INDEX ix_value_cref_vid ON value_cref(vid);

CREATE UNLOGGED TABLE value_om_mcref (
  vid bigint,                 -- references value.vid
  methodId bigint             -- references contour_method.contourId
);
COMMENT ON TABLE value_om_mcref IS 'Mapping from IOutOfModelMethodReference. All out-of-model method references associated with an eventual in-model method contour.';

CREATE INDEX ix_value_om_mcref_vid ON value_om_mcref(vid);

CREATE UNLOGGED TABLE value_om_mkeyref (
  vid bigint,                 -- references value.vid
  methodKey text              -- out-of-model method signature
);
COMMENT ON TABLE value_om_mkeyref IS 'Mapping from IOutOfModelMethodKeyReference. All out-of-model method references associated with an out-of-model method described a key (e.g., bridge method).';

CREATE INDEX ix_value_om_mkeyref_vid ON value_om_mkeyref(vid);

CREATE UNLOGGED TABLE value_om_resolved (
  vid bigint,                 -- references value.vid
  typeName text               -- actual run-time type name of the resolved value
);
COMMENT ON TABLE value_om_resolved IS 'Mapping from IResolvedValue. All resolved value references (e.g., Comparable resolved as Integer).';

CREATE INDEX ix_value_om_resolved_vid ON value_om_resolved(vid);

CREATE UNLOGGED TABLE value_thread (
  vtid bigint,                -- thread identifier
  name text                   -- thread name
);
COMMENT ON TABLE value_thread IS 'Mapping from IThreadValue. All run-time thread values.';

CREATE UNLOGGED TABLE value_file (
  vfid bigint,                -- file identifier
  name text                   -- file name
);
COMMENT ON TABLE value_file IS 'Mapping from IFileValue. All source code files executed.';

CREATE UNLOGGED TABLE value_line (
  vlid bigint,                -- line identifier
  vfid bigint,                -- references value_file.vfid
  number int                  -- line number
);
COMMENT ON TABLE value_line IS 'Mapping from ILineValue. All source code lines executed.';

/** 
 * ************************************************************
 *                      NODE MODEL SECTION                     
 * ************************************************************
 */

CREATE UNLOGGED TABLE node (
  nid bigint,                 -- unique node identifier
  kind int,
  lineFrom int,
  lineTo int,
  modifiers int[],
  name text,
  origin int,
  parentId bigint,            -- references node.nid
  visibility int
);
COMMENT ON TABLE node IS 'Mapping from ÃŒNode. Nodes represent the subject application''s static model.';

CREATE INDEX ix_node_nid ON node(nid);
CREATE INDEX ix_node_name ON node(name);

CREATE UNLOGGED TABLE node_type (
  nid bigint,                 -- references node.nid
  key text,                   -- type key
  defaultValueId int,         -- references value.vid
  superClassRefId int         -- references noderef_type.refId
);
COMMENT ON TABLE node_type IS 'Mapping from ITypeNode. Describes a type declared within a source file. Types may declare data members, method members, and other types. The node''s parent determines the the''s declaring type, if not a top-level type, or file, in the case of a top-level type.';

CREATE INDEX ix_node_type_nid ON node_type(nid);

CREATE UNLOGGED TABLE node_data (
  nid bigint,                 -- references node.nid
  defaultValueId int,         -- references value.vid
  index int,                  -- index of this member in its parent declaration
  typeRefId bigint            -- references noderef_type.refId
);
COMMENT ON TABLE node_data IS 'Mapping from IDataNode. Describes a field or local variable declared within a type or method, respectively. The node''s parent determines the data node''s declaring environment.';

CREATE INDEX ix_node_data_nid ON node_data(nid);

CREATE UNLOGGED TABLE node_method (
  nid bigint,                 -- references node.nid
  key text,                   -- method key
  index int,                  -- index of this member in its parent declaration
  returnTypeRefId bigint      -- references noderef_type.refId
);
COMMENT ON TABLE node_method IS 'Mapping from IMethodNode. Describes a method declared within a type. The node''s parent determines the method''s declaring type.';

CREATE INDEX ix_node_method_nid ON node_method(nid);

CREATE UNLOGGED TABLE noderef_method (
  refId bigint,               -- unique reference identifier
  key text                    -- node key used to resolve the node at run-time
);
COMMENT ON TABLE noderef_method IS 'Mapping from ÃŒMethodNodeRef. References to methods that *may* not have been resolved statically.';

CREATE INDEX ix_noderef_method_refId ON noderef_method(refId);

CREATE UNLOGGED TABLE noderef_type (
  refId bigint,               -- unique reference identifier
  key text                    -- node key used to resolve the node at run-time
);
COMMENT ON TABLE noderef_type IS 'Mapping from ÃŒTypeNodeRef. References to types that *may* not have been resolved statically.';

CREATE INDEX ix_noderef_type_refId ON noderef_type(refId);

CREATE UNLOGGED TABLE node_type_interface (
  nid bigint,                 -- references node_type.nid
  refId bigint                -- references noderef_type.refId 
);
COMMENT ON TABLE node_type_interface IS 'Mapping of the relationship type (1) --> (0..N) interface, which defines the ''super interfaces'' of the type.';

CREATE UNLOGGED TABLE node_method_exception (
  nid bigint,                 -- references node_method.nid
  refId bigint                -- references noderef_type.refId 
);
COMMENT ON TABLE node_method_exception IS 'Mapping of the relationship method (1) --> (0..N) thrown exception.';

/** 
 * ************************************************************
 *                DEPENDENCE GRAPH MODEL SECTION               
 * ************************************************************
 */

CREATE UNLOGGED TABLE rnode (
  rnid bigint,                -- unique resolved node identifier
  isActual boolean,           -- whether this node appears in an argument position
  isLHS boolean,              -- whether this node appears on the left hand side of an assignment
  qualifierOf bigint,         -- references rnode.rnid (this node may be the immediate qualifier of another node)
  sourceIndex int             -- the source index of this node (within its respective method)
);
COMMENT ON TABLE rnode IS 'Mapping from IResolvedNode. A node in the method dependence graph representing a method call, data, lazy data, or this reference.';

CREATE INDEX ix_rnode_rnid ON rnode(rnid);

CREATE UNLOGGED TABLE rcall (
  rnid bigint,                -- references rnode.rnid
  methodRefId bigint,         -- references noderef_method.refId 
  size int                    -- number of argument positions in the call
);
COMMENT ON TABLE rcall IS 'Mapping from IResolvedCall. A node in the method dependence graph representing a method call.';

CREATE INDEX ix_rcall_rnid ON rcall(rnid);

CREATE UNLOGGED TABLE rdata (
  rnid bigint,                -- references rnode.rnid
  dataId bigint,              -- references node_data.nid
  isDef boolean               -- determines if this is a defined node
);
COMMENT ON TABLE rdata IS 'Mapping from IResolvedData. A node in the method dependence graph representing a field or variable reference.';

CREATE INDEX ix_rdata_rnid ON rdata(rnid);

CREATE UNLOGGED TABLE rdata_lazy (
  rnid bigint,                -- references rnode.rnid
  name text,                  -- name of this data memeber
  typeRefId bigint,           -- references noderef_type.refId
  isDef boolean               -- determines if this is a defined node
);
COMMENT ON TABLE rdata_lazy IS 'Mapping from IResolvedLazyData. A node in the method dependence graph representing a lazily resolved field reference.';

CREATE INDEX ix_rdata_lazy_rnid ON rdata_lazy(rnid);

CREATE UNLOGGED TABLE rthis (
  rnid bigint,                -- references rnode.rnid
  typeId bigint               -- references node_type.nid
);
COMMENT ON TABLE rthis IS 'Mapping from IResolvedThis. A node in the method dependence graph representing a reference to a current type instance.';

CREATE INDEX ix_rthis_rnid ON rthis(rnid);

CREATE UNLOGGED TABLE mdg (
  methodId bigint,            -- references the method node for which the mdg is stored
  line int,                   -- this mdg's entry point line number
  hasSystemExit boolean       -- whether this method has a system exit (locally or transitively)
);
COMMENT ON TABLE mdg IS 'Mapping from IMethodDependenceGraph. A method dependence graph for the given method node.';

CREATE UNLOGGED TABLE rline (
  methodId bigint,            -- references the method node containing this line
  line int,                   -- this line's number
  parentLine int,             -- this line's parent line (must be in the same method)
  hasConditional boolean,
  isControl boolean,
  isLoopControl boolean,
  kind int
);
COMMENT ON TABLE rline IS 'Mapping from IResolvedLine. A node in the method dependence graph representing a line which, by assumption, contains a single statement.';

CREATE UNLOGGED TABLE rcall_uses (
  rcallId bigint,             -- references rcall.rnid
  argument int,               -- argument position in which this use appears
  rnid bigint                 -- references rnode.rnid
);
COMMENT ON TABLE rcall_uses IS 'Mapping of the relationship resolved call (1) --> (0..N) uses. Any number of nested calls and data references may appear in an argument position of a method call.';

CREATE UNLOGGED TABLE rline_defs (
  methodId bigint,            -- references the method node containing this line
  line int,                   -- references the line number for which a def is recorded
  rnid bigint                 -- references rnode.rnid
);
COMMENT ON TABLE rline_defs IS 'Mapping of the relationship resolved line (1) --> (0..N) data definition. Any number of field/local variables modified in the source line.';

CREATE UNLOGGED TABLE rline_jumps (
  methodId bigint,            -- references the method node containing this line
  line int,                   -- references the line number for which a jump is recorded
  jumpLine int                -- jump line
);
COMMENT ON TABLE rline_jumps IS 'Mapping of the relationship resolved line (1) --> (0..N) jump. Any number non-structured jumps on which this source line is control dependent.';

CREATE UNLOGGED TABLE rline_uses (
  methodId bigint,            -- references the method node containing this line
  line int,                   -- references the line number for which a use is recorded
  rnid bigint                 -- references rnode.rnid
);
COMMENT ON TABLE rline_uses IS 'Mapping of the relationship resolved line (1) --> (0..N) uses. Any number method calls and data uses appearing in this line.';

/** 
 * ************************************************************
 *             TEMPORAL SECTION OF THE JIVE SCHEMA            
 * ************************************************************
 */

/** 
 * ************************************************************
 *                    CONTOUR MODEL SECTION                   
 * ************************************************************
 */

/** 
 * The join with get_left(time) determines the type of contour:
 *
 *   METHOD_CALL...: Method Contour
 *   NEW_OBJECT....: Instance Contour
 *   TYPE_LOAD.....: Static Contour
 *
 * In the case of a method contour, the join with event also 
 * determines the thread under which the method executes. If
 * this is a static or instance contour, schemaId references 
 * node_type.nid, otherwise it references node_method.nid.
 */
CREATE UNLOGGED TABLE contour (
  contourId bigint,           -- unique contour identifier
  schemaId bigint,            -- references node.nid (ITypeNode.nid or IMethodNode.nid)
  parentId bigint,            -- references contour.contourId
  ordinal int,                -- ordinal value associated with the contour (weak identifier for contours with the same schemaId/parentId pair)
  kind int,                   -- kind of this contour
  fromTime bigint,            -- references event.eventId
  toTime bigint               -- references event.eventId
);
COMMENT ON TABLE contour IS 'Mapping from IContour. A contour represents a class, object, or method environment. It is a temporal entity that has exists for a well determined time interval.';

CREATE INDEX ix_contour_id ON contour(contourId);

CREATE OR REPLACE FUNCTION tg_contour_after_insert() RETURNS trigger AS $$
DECLARE
  cid INT;
BEGIN
  -- create non-RPDL members
  IF (NEW.kind = 4) THEN
    INSERT INTO contour_member(contourId, schemaId, valueId, fromTime)
      SELECT 
        NEW.contourId,
        nd.nId,
        nd.defaultValueId,
        NEW.fromTime
      FROM
        (node NATURAL INNER JOIN node_data) nd
      WHERE
        nd.parentId = NEW.schemaId AND nd.index <> -2 AND 15 = ANY (modifiers);
  ELSE
    INSERT INTO contour_member(contourId, schemaId, valueId, fromTime)
      SELECT 
        NEW.contourId,
        nd.nId,
        nd.defaultValueId,
        NEW.fromTime
      FROM
        (node NATURAL INNER JOIN node_data) nd
      WHERE
        nd.parentId = NEW.schemaId AND nd.index <> -2 AND 
        nd.parentId = NEW.schemaId AND nd.index <> -2 AND 15 <> ALL (modifiers);
  END IF;
  
  IF (NEW.kind = 3) THEN
    -- retrieve the contour reference of the caller
    SELECT e.callerId INTO cid FROM event_mcall e WHERE e.eventId = NEW.fromTime;

    -- create RPDL member
    INSERT INTO contour_member(contourId, schemaId, valueId, fromTime)
    SELECT 
      NEW.contourId,
      nd.nId,
      cid,
      NEW.fromTime
    FROM
      (node NATURAL INNER JOIN node_data) nd
    WHERE
      nd.parentId = NEW.schemaId AND nd.index = -2;
  END IF;

  -- return the unmodified tuple
  RETURN NEW;
END; $$ LANGUAGE 'plpgsql';
COMMENT ON FUNCTION tg_contour_after_insert() IS 'Inserts new default members for the contour.';

CREATE TRIGGER tg_contour_after_insert 
  AFTER INSERT ON contour 
  FOR EACH ROW 
  EXECUTE PROCEDURE tg_contour_after_insert();
COMMENT ON TRIGGER tg_contour_after_insert ON contour IS 'Inserts new default members for the contour.';

CREATE UNLOGGED TABLE contour_member (
  contourId bigint,           -- references contour.contourId
  schemaId bigint,            -- references node_data.nid
  valueId bigint,             -- references value.vid
  fromTime bigint,            -- references event.eventId
  toTime bigint               -- references event.eventId
);
COMMENT ON TABLE contour_member IS 'Mapping from IContourMember. A contour member represents a field or local variable.';

CREATE INDEX ix_contour_member_id ON contour_member(contourId, schemaId);

CREATE OR REPLACE FUNCTION tg_cmember_before_insert() RETURNS trigger AS $$
BEGIN
  -- set the end of the timespan of the last binding of this contour member
  UPDATE contour_member SET toTime = NEW.fromTime
  WHERE contourId = NEW.contourId AND schemaId = NEW.schemaId AND toTime IS NULL;

  -- return the unmodified tuple
  RETURN NEW;
END; $$ LANGUAGE 'plpgsql';
COMMENT ON FUNCTION tg_cmember_before_insert() IS 'Updates the lifespan of the last binding of the contour member.';

CREATE TRIGGER tg_cmember_before_insert 
  BEFORE INSERT ON contour_member
  FOR EACH ROW 
  EXECUTE PROCEDURE tg_cmember_before_insert();
COMMENT ON TRIGGER tg_cmember_before_insert ON contour_member IS 'Updates the lifespan of the last binding of the contour member.';

/** 
 * ************************************************************
 *                     EVENT MODEL SECTION                    
 * ************************************************************
 */

CREATE UNLOGGED TABLE event (
  eventId bigint,             -- unique event identifier (logical time)
  parentId bigint,            -- references event.eventId (kind is method call, thread start, or system start)
  threadId bigint,            -- references value_thread.vid
  lineId bigint,              -- references node_line.lid
  kind int
);
COMMENT ON TABLE event IS 'Mapping from DataEvent. A run-time trace event.';

CREATE UNLOGGED TABLE event_ecatch (
  eventId bigint,             -- references event.eventId
  exceptionId bigint          -- references value.vid
);
COMMENT ON TABLE event_ecatch IS 'Mapping from ExceptionCatchEvent. Identifies the caught exception.';

CREATE UNLOGGED TABLE event_ethrow (
  eventId bigint,             -- references event.eventId
  throwerId bigint,           -- references value.vid (if out-of-model) or value_cref (if in-model)
  exceptionId bigint,         -- references value.vid
  framePopped boolean
);
COMMENT ON TABLE event_ethrow IS 'Mapping from ExceptionThrowEvent. Identifies the thrown exception, the context in which it was thrown, and whether a frame was popped.';

CREATE OR REPLACE FUNCTION tg_ethrow_after_insert() RETURNS trigger AS $$
DECLARE
  cid INT;
BEGIN
  IF (NEW.framePopped) THEN
    -- contourId from the contour reference
    SELECT contourId INTO cid FROM value_cref WHERE vid = NEW.throwerId;
    
    -- set the end of the timespan of the contour
    UPDATE contour SET toTime = NEW.eventId
    WHERE toTime IS NULL AND contourId = cid;
    
    -- set the end of the timespan of the last binding of each contour member
    UPDATE contour_member SET toTime = NEW.eventId
    WHERE toTime IS NULL AND contourId = cid;
  END IF;
  
  -- return the unmodified tuple
  RETURN NEW;
END; $$ LANGUAGE 'plpgsql';
COMMENT ON FUNCTION tg_ethrow_after_insert() IS 'If the frame was popped, updates the lifespan of the method contour and its members.';

CREATE TRIGGER tg_ethrow_after_insert 
  AFTER INSERT ON event_ethrow
  FOR EACH ROW 
  EXECUTE PROCEDURE tg_ethrow_after_insert();
COMMENT ON TRIGGER tg_ethrow_after_insert ON event_ethrow IS 'If the frame was popped, updates the lifespan of the method contour and its members.';

CREATE UNLOGGED TABLE event_fread (
  eventId bigint,             -- references event.eventId
  contourId bigint,           -- references contour_member.contourId
  schemaId bigint             -- references contour_member.schemaId
);
COMMENT ON TABLE event_fread IS 'Mapping from FieldReadEvent. Identifies the contour member that was read.';

CREATE UNLOGGED TABLE event_mcall (
  eventId bigint,             -- references event.eventId
  callerId bigint,            -- references value.vid
  targetId bigint             -- references value.vid
);
COMMENT ON TABLE event_mcall IS 'Mapping from MethodCallEvent. Identifies a call made from the given caller which initiate the execution of the given target.';

CREATE INDEX ix_event_mcall_id ON event_mcall(eventId);

CREATE UNLOGGED TABLE event_mexit (
  eventId bigint,             -- references event.eventId
  returnContextId bigint,     -- references value.vid (if out-of-model) or value_cref (if in-model)
  returnValueId bigint        -- references value.vid
);
COMMENT ON TABLE event_mexit IS 'Mapping from MethodExitEvent. Identifies the returned value from a method terminating its execution.';

CREATE OR REPLACE FUNCTION tg_mexit_after_insert() RETURNS trigger AS $$
DECLARE
  cid INT;
BEGIN
  -- contourId from the contour reference
  SELECT contourId INTO cid FROM value_cref WHERE vid = NEW.returnContextId;

  -- set the end of the timespan of the contour
  UPDATE contour c SET toTime = NEW.eventId
  WHERE toTime IS NULL AND contourId = cid;

  -- set the end of the timespan of the last binding of each contour member
  UPDATE contour_member c SET toTime = NEW.eventId
  WHERE toTime IS NULL AND contourId = cid;

  -- return the unmodified tuple
  RETURN NEW;
END; $$ LANGUAGE 'plpgsql';
COMMENT ON FUNCTION tg_mexit_after_insert() IS 'Updates the lifespan of the method contour and its members.';

CREATE TRIGGER tg_mexit_after_insert 
  AFTER INSERT ON event_mexit
  FOR EACH ROW 
  EXECUTE PROCEDURE tg_mexit_after_insert();
COMMENT ON TRIGGER tg_mexit_after_insert ON event_mexit IS 'Updates the lifespan of the method contour and its members.';

-- CHECK: this could be pushed to a view (based on the most recently completed call on this thread)
CREATE UNLOGGED TABLE event_mret (
  eventId bigint,             -- references event.eventId
  terminatorId bigint         -- references event.eventId
);
COMMENT ON TABLE event_mret IS 'Mapping from MethodReturnedEvent. Identifies the terminator event associated with this returned event.';


/** 
 * ************************************************************
 *                             VIEWS
 * ************************************************************
 */

CREATE OR REPLACE VIEW vContour AS
  SELECT 
    c.contourId, 
    c.schemaId, 
    c.parentId, 
    c.ordinal,
    c.kind,
    nd.name || 
      CASE WHEN c.kind = 4 THEN '' 
           ELSE ':' || c.ordinal::text END as signature,
    (c.fromTime, c.toTime)::cinterval as span
  FROM contour c 
       INNER JOIN node nd on c.schemaId = nd.nid;
COMMENT ON VIEW vContour IS 'Contours with their signatures resolved.';

CREATE OR REPLACE VIEW vContourStatic AS
  SELECT 
    c.contourId, 
    c.schemaId, 
    c.parentId, 
    c.ordinal,
    c.signature,
    c.span
  FROM 
    vContour c 
  WHERE 
    c.kind = 4;
COMMENT ON VIEW vContourStatic IS 'Static contours returned by vContour.';

CREATE OR REPLACE VIEW vContourInstance AS
  SELECT 
    c.contourId, 
    c.schemaId, 
    c.parentId, 
    c.ordinal,
    c.signature,
    c.span
  FROM 
    vContour c 
  WHERE 
    c.kind = 1 OR c.kind = 2;
COMMENT ON VIEW vContourInstance IS 'Instance contours returned by vContour.';

CREATE OR REPLACE VIEW vContourMethod AS
  SELECT 
    c.contourId, 
    c.schemaId, 
    c.parentId, 
    c.ordinal,
    c.signature,
    c.span
  FROM 
    vContour c 
  WHERE 
    c.kind = 3;
COMMENT ON VIEW vContourMethod IS 'Method contours returned by vContour.';


CREATE OR REPLACE VIEW vContourMember AS
  SELECT
    cm.contourId, 
    cm.schemaId,
    cm.valueId,
    nd.name as member, 
    COALESCE(v.value, vc.signature) as value,
    (cm.fromTime, cm.toTime)::cinterval as span
  FROM
    contour_member cm 
    INNER JOIN node nd ON cm.schemaId = nd.nid
    LEFT JOIN value v ON v.vid = cm.valueId 
    LEFT JOIN value_cref vr ON vr.vid = cm.valueId
    LEFT JOIN vContour vc ON vc.contourId = vr.contourId;
COMMENT ON VIEW vContourMember IS 'Contour members with their textual values resolved.';

CREATE OR REPLACE VIEW vContourVariable AS
  SELECT
    cm.contourId, 
    cm.schemaId,
    cm.valueId,
    cm.member, 
    cm.value,
    cm.span
  FROM
    vContourMember cm 
    INNER JOIN contour cp ON cp.contourId = cm.contourId
  WHERE 
    cp.kind = 3;
COMMENT ON VIEW vContourVariable IS 'Variable contour members returned by vContourMember.';

CREATE OR REPLACE VIEW vContourFieldStatic AS
  SELECT
    cm.contourId, 
    cm.schemaId,
    cm.valueId,
    cm.member, 
    cm.value,
    cm.span
  FROM
    vContourMember cm 
    INNER JOIN contour cp ON cp.contourId = cm.contourId
  WHERE 
    cp.kind = 4;
COMMENT ON VIEW vContourFieldStatic IS 'Static field contour members returned by vContourMember.';

CREATE OR REPLACE VIEW vContourFieldInstance AS
  SELECT
    cm.contourId, 
    cm.schemaId,
    cm.valueId,
    cm.member, 
    cm.value,
    cm.span
  FROM
    vContourMember cm 
    INNER JOIN contour cp ON cp.contourId = cm.contourId
  WHERE 
    cp.kind = 1 OR cp.kind = 2;
COMMENT ON VIEW vContourFieldInstance IS 'Instance field contour members returned by vContourMember.';

CREATE OR REPLACE VIEW vTypeNumber AS
  SELECT 
    d.nid AS schemaId,
    n.name IN ('float', 'real', 'java.lang.Float', 'java.lang.Real') AS isReal
  FROM
    node_data d
    INNER JOIN node n ON (d.typeRefId = n.nid)
  WHERE 
    n.name IN ('byte', 'float', 'int', 'long', 'real', 'short', 'java.lang.Byte', 'java.lang.Float', 'java.lang.Integer', 'java.lang.Long', 'java.lang.Real', 'java.lang.Short');
COMMENT ON VIEW vTypeNumber IS 'Data node identifiers that represent a numeric value, either primitive or object.';

CREATE OR REPLACE VIEW vTypeBoolean AS
  SELECT 
    d.nid AS schemaId
  FROM
    node_data d
    INNER JOIN node n ON (d.typeRefId = n.nid)
  WHERE 
    n.name IN ('boolean', 'java.lang.Boolean');
COMMENT ON VIEW vTypeBoolean IS 'Data node identifiers that represent a boolean value, either primitive or object.';

CREATE OR REPLACE VIEW vTypeTextual AS
  SELECT 
    d.nid AS schemaId,
    n.name IN ('char', 'java.lang.Character') AS isChar
  FROM
    node_data d
    INNER JOIN node n ON (d.typeRefId = n.nid)
  WHERE 
    n.name IN ('char', 'java.lang.Character', 'java.lang.String');
COMMENT ON VIEW vTypeTextual IS 'Data node identifiers that represent a textual value, either primitive or object.';

CREATE OR REPLACE VIEW vTypeImplements AS
  SELECT 
    n.nid,
    n.key, 
    nt.nid AS i_nid,
    nrt.refid AS i_refid,
    COALESCE(nt.key, nrt.key) AS i_key
  FROM 
    (node_type_interface NATURAL JOIN node_type) n
    LEFT JOIN node_type nt ON n.refid = nt.nid
    LEFT JOIN noderef_type nrt ON n.refid = nrt.refid;
COMMENT ON VIEW vTypeImplements IS 'Lists the interfaces that are direct parents of each type.';

CREATE OR REPLACE VIEW vMethodThrows AS
  SELECT 
    n.nid,
    n.key, 
    nt.nid AS e_nid,
    nrt.refid AS e_refid,
    COALESCE(nt.key, nrt.key) AS e_key
  FROM 
    (node_method_exception NATURAL JOIN node_method) n
    LEFT JOIN node_type nt ON n.refid = nt.nid
    LEFT JOIN noderef_type nrt ON n.refid = nrt.refid;
COMMENT ON VIEW vMethodThrows IS 'Lists the thrown exceptions declared by each method.';

--EXPLAIN ANALYZE SELECT * FROM vContour;
--EXPLAIN ANALYZE SELECT * FROM vContourMethod;
--EXPLAIN ANALYZE SELECT * FROM vContourInstance;
--EXPLAIN ANALYZE SELECT * FROM vContourStatic;

--EXPLAIN ANALYZE SELECT * FROM vContourMember;
--EXPLAIN ANALYZE SELECT * FROM vContourVariable;
--EXPLAIN ANALYZE SELECT * FROM vContourFieldInstance;
--EXPLAIN ANALYZE SELECT * FROM vContourFieldStatic;

--EXPLAIN ANALYZE SELECT * FROM vTypeBoolean;
--EXPLAIN ANALYZE SELECT * FROM vTypeNumber;
--EXPLAIN ANALYZE SELECT * FROM vTypeTextual;

--EXPLAIN ANALYZE SELECT cfi.*, t.* FROM vContourFieldInstance cfi NATURAL JOIN vTypeNumber t
--EXPLAIN ANALYZE SELECT cfi.*, t.* FROM vContourFieldInstance cfi NATURAL JOIN vTypeTextual t
--EXPLAIN ANALYZE SELECT cfi.*, t.* FROM vContourFieldInstance cfi NATURAL JOIN vTypeBoolean t

--EXPLAIN ANALYZE SELECT c.*, cm.* FROM vContourMethod c INNER JOIN vContourVariable cm ON (c.contourId = cm.contourId) order by (c.span::cinterval)._left, (cm.span::cinterval)._left, member;

/** 
 * ************************************************************
 *                     REAL-TIME EXTENSIONS
 * ************************************************************
 */

CREATE TABLE thread_state AS (
  SELECT id, name FROM 
  (VALUES
    (1,'TS_CREATED'),
    (2,'TS_RUNNING'),
    (3,'TS_BLOCKED'),
    (4,'TS_WAITING'),
    (5,'TS_TERMINATED')) AS R(id, name)
);
COMMENT ON TABLE thread_state IS 'Thread states tracked on real-time executions.';

CREATE UNLOGGED TABLE thread (
  threadId bigint,            -- references value_thread.vtid
  stateId int,                -- references thread_state.id 
  fromTime bigint,            -- references event.eventId
  toTime bigint               -- references event.eventId
);
COMMENT ON TABLE thread IS 'Thread states during execution.';

CREATE INDEX ix_thread_threadId ON thread(threadId);

CREATE UNLOGGED TABLE monitor (
  monitor text,               -- references event_rtmonitor.monitor
  holder bigint,              -- references value_thread.vtid
  lockCount int,              -- number of locks held on the monitor
  fromTime bigint,            -- references event.eventId
  toTime bigint               -- references event.eventId
);
COMMENT ON TABLE monitor IS 'Monitor states during execution.';

CREATE INDEX ix_monitor_monitor ON monitor(monitor);
CREATE INDEX ix_monitor_holder ON monitor(holder);

CREATE UNLOGGED TABLE event_rt (
  eventId bigint,             -- references event.eventId
  eventTime bigint            -- wall time
);
COMMENT ON TABLE event_rt IS 'Mapping from IRealTime. A real-time event.';

CREATE UNLOGGED TABLE event_rtmonitor (
  eventId bigint,             -- references event.eventId (kinds: 11..16)
  monitor text                -- monitor on which the event occurred
);
COMMENT ON TABLE event_rtmonitor IS 'Mapping from IMonitorEvent. A real-time event referencing a monitor.';

CREATE UNLOGGED TABLE event_rtsleep (
  eventId bigint,             -- references event.eventId
  wakeTime bigint             -- time indicating when the thread woke up
);
COMMENT ON TABLE event_rtsleep IS 'Mapping from IThreadSleepEvent. A real-time event indicating a thread sleep.';

CREATE UNLOGGED TABLE event_rtthread (
  eventId bigint,             -- references event.eventId (kind is method call, thread start, or system start)
  priority int,               -- new priority of the thread
  scheduler text              -- scheduler controlling this thread
);
COMMENT ON TABLE event_rtthread IS 'Mapping from IRealTimeThreadEvent. A real-time thread event.';

CREATE UNLOGGED TABLE event_rtthreadnew (
  eventId bigint,             -- references event.eventId (kind is method call, thread start, or system start)
  newThreadId int             -- references value_thread.vtid
);
COMMENT ON TABLE event_rtthreadnew IS 'Mapping from IThreadNewEvent. A real-time thread creation event.';

CREATE OR REPLACE FUNCTION db_after_load() RETURNS VOID AS $$
DECLARE
  old_state INT;
  new_state INT;
  ev RECORD;
  mon RECORD;
BEGIN

  /*
    (11,'MONITOR_LOCK_BEGIN'),      
    (12,'MONITOR_LOCK_END'),        
    (13,'MONITOR_LOCK_FAST'),       
    (14,'MONITOR_RELOCK'),          
    (15,'MONITOR_UNLOCK_BEGIN'),    
    (16,'MONITOR_UNLOCK_COMPLETE'), 
    (17,'MONITOR_UNLOCK_END'),      
    (18,'MONITOR_UNLOCK_FAST'),     
    ...
    (22,'THREAD_CREATE'),           
    (23,'THREAD_END'),              
    (24,'THREAD_PRIORITY'),         
    (25,'THREAD_SLEEP'),            
    (26,'THREAD_START'),            
    (27,'THREAD_WAKE'),             
    (28,'THREAD_YIELD'),            
  */
  FOR ev IN SELECT eventId, threadId, kind, monitor 
            FROM (event NATURAL LEFT JOIN event_rtmonitor)
            WHERE kind IN (11, 12, 13, 14, 16, 17, 18, 22, 23, 24, 25, 26, 27, 28)
            ORDER BY eventId 
  LOOP
  
    /*
      Monitor Events
      ----------------
      (11,'MONITOR_LOCK_BEGIN'),      -- 
      (12,'MONITOR_LOCK_END'),        -- holder --> event's thread (+1)
      (13,'MONITOR_LOCK_FAST'),       -- holder --> event's thread (+1)
      (14,'MONITOR_RELOCK'),          -- holder --> event's thread (set to prior)
      (15,'MONITOR_UNLOCK_BEGIN'),    -- 
      (16,'MONITOR_UNLOCK_COMPLETE'), -- holder --> event's thread (set to zero)
      (17,'MONITOR_UNLOCK_END'),      -- holder --> event's thread (-1)
      (18,'MONITOR_UNLOCK_FAST'),     -- holder --> event's thread (-1)
    */
    IF (ev.kind IN (12, 13, 14, 16, 17, 18)) THEN
   
      -- update old monitor state
      UPDATE monitor SET toTime = ev.eventId WHERE monitor = ev.monitor AND toTime IS NULL;

      -- last change on this monitor is the record with toTime = ev.eventId
      SELECT INTO mon holder, lockCount FROM monitor WHERE toTime = ev.eventId;
    
      -- infer first state of the monitor for BEFORE the first time locks are acquired
      IF (ev.kind IN (12, 13)) THEN

        INSERT INTO monitor(monitor, holder, lockCount, fromTime, toTime)
        SELECT
          ev.monitor,
          NULL,
          0,
          0,
          ev.eventId
        WHERE NOT EXISTS(SELECT 1 FROM monitor WHERE monitor = ev.monitor);

      END IF;

      -- create new monitor state
      INSERT INTO monitor(monitor, holder, lockCount, fromTime)
      VALUES(
        ev.monitor,
        CASE 
          -- simple decrement reaches zero (for UNLOCK COMPLETE, we need the holder)
          WHEN ev.kind IN (17, 18) AND mon.lockCount - 1 = 0 THEN NULL
          -- otherwise, keep track of the holder
          ELSE ev.threadId
        END,
        CASE 
          -- simple increment
          WHEN ev.kind IN (12, 13) THEN COALESCE(mon.lockCount, 0) + 1
          -- simple decrement
          WHEN ev.kind IN (17, 18) THEN mon.lockCount - 1
          -- decrement to zero
          WHEN ev.kind = 16 THEN 0
          -- restore the count to the value prior to the last UNLOCK COMPLETE on this monitor
          ELSE (SELECT lockCount FROM monitor mi 
                WHERE toTime = (SELECT MAX(fromTime) FROM monitor mi INNER JOIN event e ON e.eventId = mi.fromTime
                                WHERE e.kind = 16 AND mi.monitor = ev.monitor AND mi.holder = mon.holder))
        END,
        ev.eventId);

    END IF;
  
    /*
      (11,'MONITOR_LOCK_BEGIN'),      -- thread_state --> TS_BLOCKED
      (12,'MONITOR_LOCK_END'),        -- thread_state --> TS_RUNNING
      (13,'MONITOR_LOCK_FAST'),       -- thread_state --> TS_RUNNING
      (14,'MONITOR_RELOCK'),          -- thread_state --> TS_RUNNING
      (15,'MONITOR_UNLOCK_BEGIN'),    -- thread_state --> unchanged
      (16,'MONITOR_UNLOCK_COMPLETE'), -- thread_state --> unchanged
      (17,'MONITOR_UNLOCK_END'),      -- thread_state --> unchanged
      (18,'MONITOR_UNLOCK_FAST'),     -- thread_state --> unchanged
      (19,'NEW_OBJECT'),
      (20,'SYSTEM_END'),
      (21,'SYSTEM_START'),
      (22,'THREAD_CREATE'),           -- thread_state --> TS_CREATED
      (23,'THREAD_END'),              -- thread_state --> TS_TERMINATED
      (24,'THREAD_PRIORITY'),         -- thread_state --> unchanged
      (25,'THREAD_SLEEP'),            -- thread_state --> TS_WAITING
      (26,'THREAD_START'),            -- thread_state --> TS_RUNNING
      (27,'THREAD_WAKE'),             -- thread_state --> TS_RUNNING
      (28,'THREAD_YIELD'),            -- thread_state --> TS_WAITING
    */
    IF (ev.kind = 22) THEN

      -- TS_CREATED requires special treatment
      INSERT INTO thread(threadId, stateId, fromTime)
      SELECT
        e.newThreadId, 
        1,
        e.eventId
      FROM (event NATURAL JOIN event_rtthreadnew) e
      WHERE e.eventId = ev.eventId;

    ELSIF (ev.kind IN (11, 12, 13, 14, 23, 25, 26, 27, 28)) THEN

      -- old thread state
      SELECT INTO old_state stateId FROM thread t WHERE t.threadId = ev.threadId AND toTime IS NULL;
    
      -- new thread state
      SELECT INTO new_state 
        CASE 
          -- TS_RUNNING
          WHEN e.kind IN (12, 13, 14, 26, 27) THEN 2
          -- TS_BLOCKED
          WHEN e.kind = 11 THEN 3
          -- TS_WAITING
          WHEN e.kind IN (25, 28) THEN 4
          -- TS_TERMINATED
          ELSE 5
        END
      FROM event e
      WHERE e.eventId = ev.eventId;

      -- there a state change
      IF (new_state <> COALESCE(old_state, new_state)) THEN

        -- update old thread state
        UPDATE thread SET toTime = ev.eventId WHERE threadId = ev.threadId AND toTime IS NULL;

        IF (ev.kind <> 23) THEN
          -- create the new state record
          INSERT INTO thread(threadId, stateId, fromTime)
          VALUES(ev.threadId, new_state, ev.eventId);

        END IF;
      
      END IF;
    
    END IF;

  END LOOP;
  
END; $$ LANGUAGE 'plpgsql';
COMMENT ON FUNCTION db_after_load() IS 'Updates the state of monitors and threads for real-time executions.';


/** 
 * ************************************************************
 *                       ADMIN (INTERNAL)
 * ************************************************************
 */

CREATE OR REPLACE VIEW va_countDynamic AS 
  SELECT 'contour' AS name, COUNT(*) AS rows FROM contour
  UNION SELECT 'contour_member' AS name, COUNT(*) AS rows FROM contour_member
  UNION SELECT 'event' AS name, COUNT(*) AS rows FROM event
  UNION SELECT 'event_ecatch' AS name, COUNT(*) AS rows FROM event_ecatch
  UNION SELECT 'event_ethrow' AS name, COUNT(*) AS rows FROM event_ethrow
  UNION SELECT 'event_fread' AS name, COUNT(*) AS rows FROM event_fread
  UNION SELECT 'event_mcall' AS name, COUNT(*) AS rows FROM event_mcall
  UNION SELECT 'event_mexit' AS name, COUNT(*) AS rows FROM event_mexit
  UNION SELECT 'event_mret' AS name, COUNT(*) AS rows FROM event_mret;
COMMENT ON VIEW va_countDynamic IS 'Admin view to count the number of records in all dynamic data tables.';

CREATE OR REPLACE VIEW va_countDynamic2 AS 
  SELECT 'contour' AS name, COUNT(*) AS rows FROM contour
  UNION SELECT 'contour_member' AS name, COUNT(*) AS rows FROM contour_member
  UNION SELECT 'thread' AS name, COUNT(*) AS rows FROM thread
  UNION SELECT 'monitor' AS name, COUNT(*) AS rows FROM monitor
  UNION SELECT 'event' AS name, COUNT(*) AS rows FROM event
  UNION SELECT 'event_ecatch' AS name, COUNT(*) AS rows FROM event_ecatch
  UNION SELECT 'event_ethrow' AS name, COUNT(*) AS rows FROM event_ethrow
  UNION SELECT 'event_fread' AS name, COUNT(*) AS rows FROM event_fread
  UNION SELECT 'event_mcall' AS name, COUNT(*) AS rows FROM event_mcall
  UNION SELECT 'event_mexit' AS name, COUNT(*) AS rows FROM event_mexit
  UNION SELECT 'event_mret' AS name, COUNT(*) AS rows FROM event_mret
  UNION SELECT 'event_rt' AS name, COUNT(*) AS rows FROM event_rt
  UNION SELECT 'event_rtmonitor' AS name, COUNT(*) AS rows FROM event_rtmonitor
  UNION SELECT 'event_rtsleep' AS name, COUNT(*) AS rows FROM event_rtsleep
  UNION SELECT 'event_rtthread' AS name, COUNT(*) AS rows FROM event_rtthread
  UNION SELECT 'event_rtthreadnew' AS name, COUNT(*) AS rows FROM event_rtthreadnew;
COMMENT ON VIEW va_countDynamic IS 'Admin view to count the number of records in all dynamic data tables, including real-time ones.';

CREATE OR REPLACE VIEW va_countStatic AS 
  SELECT 'mdg' AS name, COUNT(*) AS rows FROM mdg
  UNION SELECT 'node' AS name, COUNT(*) AS rows FROM node
  UNION SELECT 'node_data' AS name, COUNT(*) AS rows FROM node_data
  UNION SELECT 'node_method' AS name, COUNT(*) AS rows FROM node_method
  UNION SELECT 'node_method_exception' AS name, COUNT(*) AS rows FROM node_method_exception
  UNION SELECT 'noderef_method' AS name, COUNT(*) AS rows FROM noderef_method
  UNION SELECT 'noderef_type' AS name, COUNT(*) AS rows FROM noderef_type
  UNION SELECT 'node_type' AS name, COUNT(*) AS rows FROM node_type
  UNION SELECT 'node_type_interface' AS name, COUNT(*) AS rows FROM node_type_interface
  UNION SELECT 'rcall' AS name, COUNT(*) AS rows FROM rcall
  UNION SELECT 'rcall_uses' AS name, COUNT(*) AS rows FROM rcall_uses
  UNION SELECT 'rdata' AS name, COUNT(*) AS rows FROM rdata
  UNION SELECT 'rdata_lazy' AS name, COUNT(*) AS rows FROM rdata_lazy
  UNION SELECT 'rline' AS name, COUNT(*) AS rows FROM rline
  UNION SELECT 'rline_defs' AS name, COUNT(*) AS rows FROM rline_defs
  UNION SELECT 'rline_jumps' AS name, COUNT(*) AS rows FROM rline_jumps
  UNION SELECT 'rline_uses' AS name, COUNT(*) AS rows FROM rline_uses
  UNION SELECT 'rnode' AS name, COUNT(*) AS rows FROM rnode
  UNION SELECT 'rthis' AS name, COUNT(*) AS rows FROM rthis
  UNION SELECT 'value' AS name, COUNT(*) AS rows FROM value
  UNION SELECT 'value_cref' AS name, COUNT(*) AS rows FROM value_cref
  UNION SELECT 'value_file' AS name, COUNT(*) AS rows FROM value_file
  UNION SELECT 'value_line' AS name, COUNT(*) AS rows FROM value_line
  UNION SELECT 'value_om_mcref' AS name, COUNT(*) AS rows FROM value_om_mcref
  UNION SELECT 'value_om_mkeyref' AS name, COUNT(*) AS rows FROM value_om_mkeyref
  UNION SELECT 'value_om_resolved' AS name, COUNT(*) AS rows FROM value_om_resolved
  UNION SELECT 'value_thread' AS name, COUNT(*) AS rows FROM value_thread;
COMMENT ON VIEW va_countStatic IS 'Admin view to count the number of records in all static data tables.';

CREATE OR REPLACE VIEW va_ImportNode AS
  SELECT nid, kind, lineFrom, lineTo, modifiers, name, origin, parentId, parentKind, parentName, parentKey, visibility
  FROM
    (SELECT 
       n.nid, 
       n.kind, 
       n.lineFrom, 
       n.lineTo, 
       n.modifiers, 
       n.name, 
       n.origin, 
       n.parentId, 
       p.kind AS parentKind, 
       p.name AS parentName, 
       COALESCE(nt.key, nm.key) AS parentKey, 
       n.visibility, 
       false AS isRef 
     FROM node n 
          INNER JOIN node p on n.parentId = p.nid
          LEFT JOIN node_type nt on n.parentId = nt.nid
          LEFT JOIN node_method nm on n.parentId = nm.nid
     UNION SELECT refid, 2, null, null, null, null, null, null, null, null, null, null, true AS isRef FROM noderef_type
     UNION SELECT refid, 7, null, null, null, null, null, null, null, null, null, null, true AS isRef FROM noderef_method) AS U;

CREATE OR REPLACE VIEW va_ImportNodeType AS
  SELECT   
    nt.key,                   
    nt.defaultValueId,
    nt.superClassRefId,
    st.key AS superKey
  FROM node_type nt 
       LEFT JOIN node_type st ON nt.superClassRefId = st.nid;

CREATE OR REPLACE VIEW va_ImportNodeData AS
  SELECT   
    nd.defaultValueId,
    nd.index,
    nd.typeRefId,
    COALESCE(dt.key, rdt.key) AS typeKey
  FROM node_data nd 
       LEFT JOIN node_type dt ON nd.typeRefId = dt.nid
       LEFT JOIN noderef_type rdt ON nd.typeRefId = rdt.refid;

CREATE OR REPLACE VIEW va_ImportNodeMethod AS
  SELECT   
    nm.key,                   
    nm.index,         
    nm.returnTypeRefId,
    COALESCE(dt.key, rdt.key) AS returnTypeKey
  FROM node_method nm 
       LEFT JOIN node_type dt ON nm.returnTypeRefId = dt.nid
       LEFT JOIN noderef_type rdt ON nm.returnTypeRefId = rdt.refid;

CREATE OR REPLACE VIEW va_ImportValue AS
  SELECT 
    vid, 
    kind, 
    value, 
    contourid
  FROM
    (SELECT vid, kind, NULL AS value, contourid FROM value_cref 
     UNION SELECT vid, kind, value, NULL AS contourid FROM value) AS U;

CREATE OR REPLACE VIEW va_ImportLine AS
  SELECT 
    vlid, 
    name AS fileName, 
    number AS lineNumber 
  FROM value_line vl 
       INNER JOIN value_file vf ON vl.vfid = vf.vfid;

CREATE OR REPLACE VIEW va_ImportEvent AS
  SELECT 
    eventId, 
    parentId, 
    threadId, 
    kind, 
    fileName, 
    lineNumber 
  FROM event e 
       INNER JOIN va_ImportLine vl ON e.lineId = vl.vlId;

CREATE OR REPLACE VIEW va_ImportEventCatch AS
  SELECT 
    eventId,
    kind,
    value,
    contourId
  FROM event_ecatch e 
       INNER JOIN va_ImportValue v ON e.exceptionid = v.vid;


CREATE OR REPLACE VIEW va_ImportEventThrow AS
  SELECT 
    eventId,
    framePopped,
    tv.kind AS throwerKind,
    tv.value AS throwerValue,
    throwerId AS throwerValueId,
    tv.contourId AS throwerContourId,
    ev.kind AS exceptionKind,
    ev.value AS exceptionValue,
    ev.contourId AS exceptionContourId
  FROM event_ethrow e 
       INNER JOIN va_ImportValue tv ON e.throwerId = tv.vid
       INNER JOIN va_ImportValue ev ON e.exceptionId = ev.vid;
       
-- CREATE OR REPLACE FUNCTION tg_event_rt_after_insert() RETURNS trigger AS $$
-- DECLARE
--   old_state INT;
--   new_state INT;
--   new_monitor TEXT;
--   ev RECORD;
--   rec RECORD;
-- BEGIN
--   -- this record kind
--   SELECT INTO ev e.threadId, e.kind FROM event e WHERE e.eventId = NEW.eventId;
-- 
--   /*
--     Monitor Events
--     ----------------
--     (11,'MONITOR_LOCK_BEGIN'),      -- 
--     (12,'MONITOR_LOCK_END'),        -- holder --> event's thread (+1)
--     (13,'MONITOR_LOCK_FAST'),       -- holder --> event's thread (+1)
--     (14,'MONITOR_RELOCK'),          -- holder --> event's thread (set to prior)
--     (15,'MONITOR_UNLOCK_BEGIN'),    -- 
--     (16,'MONITOR_UNLOCK_COMPLETE'), -- holder --> event's thread (set to zero)
--     (17,'MONITOR_UNLOCK_END'),      -- holder --> event's thread (-1)
--     (18,'MONITOR_UNLOCK_FAST'),     -- holder --> event's thread (-1)
--   */
--   IF (ev.kind IN (12, 13, 14, 16, 17, 18)) THEN
--     -- retrieve the monitor
--     SELECT INTO new_monitor monitor FROM event_rtmonitor WHERE eventId = NEW.eventId;
--     
--     -- update old monitor state
--     UPDATE monitor SET toTime = NEW.eventId WHERE monitor = new_monitor AND toTime IS NULL;
-- 
--     -- last change on this monitor is the record with toTime = NEW.eventId
--     SELECT INTO rec m.holder, m.lockCount FROM monitor m WHERE m.toTime = NEW.eventId;
--     
--     -- infer first state of the monitor for BEFORE the first time locks are acquired
--     IF (ev.kind IN (12, 13)) THEN
-- 
--       INSERT INTO monitor(monitor, holder, lockCount, fromTime, toTime)
--       SELECT
--         new_monitor,
--         NULL,
--         0,
--         0,
--         NEW.eventId
--       WHERE NOT EXISTS(SELECT 1 FROM monitor WHERE monitor = new_monitor);
-- 
--     END IF;
-- 
--     -- create new monitor state
--     INSERT INTO monitor(monitor, holder, lockCount, fromTime)
--     VALUES(
--       new_monitor,
--       CASE 
--         -- simple decrement reaches zero (for UNLOCK COMPLETE, we need the holder)
--         WHEN ev.kind IN (17, 18) AND rec.lockCount - 1 = 0 THEN NULL
--         -- otherwise, keep track of the holder
--         ELSE ev.threadId
--       END,
--       CASE 
--         -- simple increment
--         WHEN ev.kind IN (12, 13) THEN COALESCE(rec.lockCount, 0) + 1
--         -- simple decrement
--         WHEN ev.kind IN (17, 18) THEN rec.lockCount - 1
--         -- decrement to zero
--         WHEN ev.kind = 16 THEN 0
--         -- restore the count to the value prior to the last UNLOCK COMPLETE on this monitor
--         ELSE (SELECT lockCount FROM monitor mi 
--               WHERE toTime = (SELECT MAX(fromTime) FROM monitor mi INNER JOIN event e ON e.eventId = mi.fromTime
--                               WHERE e.kind = 16 AND mi.monitor = new_monitor AND mi.holder = rec.holder))
--       END,
--       NEW.eventId);
-- 
--   END IF;
--   
--   /*
--     (11,'MONITOR_LOCK_BEGIN'),      -- thread_state --> TS_BLOCKED
--     (12,'MONITOR_LOCK_END'),        -- thread_state --> TS_RUNNING
--     (13,'MONITOR_LOCK_FAST'),       -- thread_state --> TS_RUNNING
--     (14,'MONITOR_RELOCK'),          -- thread_state --> TS_RUNNING
--     (15,'MONITOR_UNLOCK_BEGIN'),    -- thread_state --> unchanged
--     (16,'MONITOR_UNLOCK_COMPLETE'), -- thread_state --> unchanged
--     (17,'MONITOR_UNLOCK_END'),      -- thread_state --> unchanged
--     (18,'MONITOR_UNLOCK_FAST'),     -- thread_state --> unchanged
--     (19,'NEW_OBJECT'),
--     (20,'SYSTEM_END'),
--     (21,'SYSTEM_START'),
--     (22,'THREAD_CREATE'),           -- thread_state --> TS_CREATED
--     (23,'THREAD_END'),              -- thread_state --> TS_TERMINATED
--     (24,'THREAD_PRIORITY'),         -- thread_state --> unchanged
--     (25,'THREAD_SLEEP'),            -- thread_state --> TS_WAITING
--     (26,'THREAD_START'),            -- thread_state --> TS_RUNNING
--     (27,'THREAD_WAKE'),             -- thread_state --> TS_RUNNING
--     (28,'THREAD_YIELD'),            -- thread_state --> TS_WAITING
--   */
--   IF (ev.kind = 22) THEN
-- 
--     -- TS_CREATED requires special treatment
--     INSERT INTO thread(threadId, stateId, fromTime)
--     SELECT
--       e.newThreadId, 
--       1,
--       e.eventId
--     FROM (event NATURAL JOIN event_rtthreadnew) e
--     WHERE e.eventId = NEW.eventId;
-- 
--   ELSIF (ev.kind IN (11, 12, 13, 14, 23, 25, 26, 27, 28)) THEN
-- 
--     -- old thread state
--     SELECT INTO old_state stateId FROM thread t WHERE t.threadId = ev.threadId AND toTime IS NULL;
--     
--     -- new thread state
--     SELECT INTO new_state 
--       CASE 
--         -- TS_RUNNING
--         WHEN e.kind IN (12, 13, 14, 26, 27) THEN 2
--         -- TS_BLOCKED
--         WHEN e.kind = 11 THEN 3
--         -- TS_WAITING
--         WHEN e.kind IN (25, 28) THEN 4
--         -- TS_TERMINATED
--         ELSE 5
--       END
--     FROM event e
--     WHERE e.eventId = NEW.eventId;
-- 
--     -- there a state change
--     IF (new_state <> COALESCE(old_state, new_state)) THEN
-- 
--       -- update old thread state
--       UPDATE thread SET toTime = NEW.eventId WHERE threadId = ev.threadId AND toTime IS NULL;
-- 
--       IF (ev.kind <> 23) THEN
--         -- create the new state record
--         INSERT INTO thread(threadId, stateId, fromTime)
--         VALUES(ev.threadId, new_state, NEW.eventId);
-- 
--       END IF;
--       
--     END IF;
--     
--   END IF;
-- 
--   -- return the unmodified tuple
--   RETURN NEW;
-- END; $$ LANGUAGE 'plpgsql';
-- COMMENT ON FUNCTION tg_event_rt_after_insert() IS 'Updates the state of monitors and threads in real-time executions.';
-- 
-- CREATE TRIGGER tg_event_rt_after_insert 
--   AFTER INSERT ON event_rt
--   FOR EACH ROW 
--   EXECUTE PROCEDURE tg_event_rt_after_insert();
-- COMMENT ON TRIGGER tg_event_rt_after_insert ON event_rt IS 'Updates the state of monitors and threads in real-time executions.';
